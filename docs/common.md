# General JS Structure

We use QuickJS under the hood. Since it doesn't rely on C++, it offers good performance.

We use the TypeScript compiler (tsc) from Node.js. Therefore, it needs to understand what and how to compile, so the resulting *.js files can be consumed by QuickJS. The most convenient approach was to avoid modules and place all functionality in `JSValue` at startup. Standard features like timers are placed in the `global_object`. All our specific functionality is in the `mtjs` object.

The goal of the runtime is to create a high-speed engine for backends and incorporate the necessary features under the hood. Everything is done in a single static build. Why? The reason is that when software is updated in parts, each update must be tracked, and the code must be reviewed from a security perspective. Many remember how the Solana blockchain was recently compromised. It was attacked through a method that involved injecting a backdoor into an open-source project that was automatically updated.

A static build doesn't need constant updates. It must be replaced carefully, after thorough testing, as something might change.

Under the hood, MTJS uses the Megatron framework. It is written in C++ close to pure C, achieving high performance. The code is not yet released, as the non-standard C++ style tends to attract criticism from advocates of modern, efficient C++. We avoid using Boost and constructs that migrated from it to the standard, like `std::shared_ptr`. Instead of `std::shared_ptr`, we use a custom intrusive pointer. Interestingly, our pointer is three times faster than `std::shared_ptr` in construction, and it doesn't require workarounds like `std::enable_shared_from_this`. The efficiency of standard C++ code is well demonstrated by the example of a server using Boost.Asio, which is about 2.5 times slower than our JS. The slowdown from standard features is also evident when compared to userver. It is still about 7% slower than MTJS, despite the Yandex team's tremendous efforts to optimize it. Recently, they even outperformed Go's `net/http`.

Some might argue that V8 provides more efficient JS execution compared to QuickJS. However, this is debatable, as access to objects within a scope is still done by their names. You can experiment with the code by adding logic inside HTTP request handling and observe how the speed changes. I tried it, and it looks very promising.

To facilitate interaction between hosts, we implemented an RPC system from Megatron under the hood. RPC makes it very easy to send events between hosts and can replace the use of message brokers like RabbitMQ. An event can pass through multiple hosts, and the route it takes is stored within the event. You can simply issue a reply somewhere, and it will return to the original sender. Using a message broker is inherently slower than having it embedded within the application, as there is no network latency between the application and the broker.

To attract attention to MTJS as a tool for embedded development, we implemented Telnet. It's quite easy to create application management via a Telnet console in the style of Cisco routers, which is currently a standard for various types of routers.