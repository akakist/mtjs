# Общая структура JS

Мы используем под капотом quickjs. За счет того, что в нем не используется c++, он имеет хорошую скорость.

Мы используем tsc компилятор из node.js.
Поэтому нужно, чтобы он понимал что и как, а результат *.js мог скушать quickjs.
Получилось удобнее всего обойтись без модулей, а на старте расположить весь функционал в JSValue.
Стандартные вещи типа таймера размещаются в global_object. Все наше специфичное - в обьекте mtjs.

Цель  рантайма - сделать скоростной движок для бекендов и запихать под капот нужные фичи.
Все делается в одном static билде. Почему?
Дело в том, что когда софт обновляется кусками, нужно отслеживать каждое обновление и смотреть код с позиции обеспечения безопасности.
Многие помнят как не так давно подломали блокчейн Solana. Там использовался метод внедрения закладки в opensource проект, который автоматически апдейтился.

Статик билд не нужно постоянно апдейтить. Eго нужно заменять осторожно, сначала все вытестив, поскольку что-то может поменяться.

Под капотом MTJS используется фреймворк megatron. Он написан на c++, приближенном в чистому С. За счет этого достигается высокая скорость.
Код пока не выкладывается, поскольку нестандартный стиль на c++ вызывает хейт со стороны адептов современного эффективного c++.
Мы не пользуемся boost и всеми конструкциями, перекочевавшими из него в стандарт, типа std::shared_ptr. Вместо std::shared_ptr используется самописный intrusive ptr. Что интересно, на конструкторе наш ptr в 3 раза быстрее std::shared_ptr, плюс не нужны костыли типа std::enable_shared_from_this.
Эффективность кода на стандартном   C++  хорошо демонстрируется примером сервера на boost.asio. Он примерно в 2.5 раза тормознее нашего js.
Тормоза от стандартных фич хорошо видны и в сравнении с userver. Он все равно тормознее mtjs примерно на 7%, хотя команда Яндекса прикладывает титанические усилия по его ускорению. Они в последнее время  даже победили  GO с "net/http".


Кто-то скажет, что V8 дает более эффективное исполнение js  по сравнению с quckjs. Однако это спорный вопрос, поскольку в любом случае доступ к обьектам внутри scope идет по их именам.
Можно поиграться с кодом, добавив какую-то логику внутри обработки http запроса и посмотреть как именится скорость. Я пробовал - все выглядит очень неплохо.

Для организации взаимодействия между хостами мы сделали под капотом RPC от мегатрона.
RPC позволяет очень просто посылать события между хостами и может заменить использование брокеров сообщений типа rabbitMQ.
Событие может проходить несколько хостов и пройденный маршрут запоминается внутри события. Можно просто сделать где-то reply и оно вернется тому, кто послал его первым.
Использование брокера сообщений заведомо тормознее, чем если он встроен внутри приложения, поскольку нет задержки по сети между приложением и брокером.

Для привлечения внимания mtjs в качестве средства для разработки embedded, мы сделали телнет. Довольно просто сделать управление приложением через телнет консоль в стиле cisco routers, что сейчас является стандартом для разного рода маршрутизаторов.