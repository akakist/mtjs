Концепция сервисно-ориентированного программирования.

Все мы помним, что выполнение программы начинается с функции main().
Eсть куча кода в приложении, который готовит среду для выполнения main(), инициализируются глобальные переменные, 
устанавливаются параметры командной строки argv.

Программа последовательно выполнилась, вычислились какие-то данные, создался архив, 
вытянулись данные из репозитария, скомпилялся какой-то код.
Программа завершилась с каким-то кодом возврата, который можно словить в скрипте bash.
Особенность данной схемы - есть начало выполнения программы и есть конец.

Следовательно, стандартный компилятор C++ - это фреймворк для программ, которые выполняют разовую работу и завершаются по выполнении.

Рассмотрим иную задачу: у нас есть GUI. Там никакую работу выполнять не нужно. 
Нужно просто ожидать действий юзера в виде нажатий на мышку или клавиатуру и выполнять какие-то действия. 
Уже совсем иная архитектура. Нет никакого последовательного выполнения.
Чтобы работать с GUI используют различные фреймворки наподобие Qt или  WinAPI.
Их общая особенность - наличие eventloop - цикла, который обрабатывает события вроде нажатия на кнопку мышки.
GUI фреймворк предоставляет также возможность удобного рисования кнопок, сам рисует курсор мышки. 
Все, что остается программисту - указать фреймворку как нарисовать графические элементы и самому запрограммировать реакцию на действия юзера. Все.

Eще задача: нам нужно написать сервер.
Сервер также не выполняется разово, а висит в памяти и ожидает каких-то событий - если это http сервер, 
то он ожидает входящих запросов на каком-то порту. То есть вместо нажатия кнопки мышки как GUI, 
сервер ловит входящие запросы, вычисляет ответ и отдает его клиенту.
Как это реализовать? Первое, что приходит в голову - как сделано в GUI фреймворках. 
Eсть нечто, куда приходит событие о входящем запросе.
То есть это опять eventloop. Eventloop предоставляет программисту функцию WindowProc, в которой делается обработка входящих событий.
Разумеется, мы ее назовем не WindowProc, a, допустим, handleEvent.

Как мы назовем обьект, который содержит отдельный eventloop? А давайте назовем его "сервис".

Какие могут быть у сервиса общие свойства?
1. Наличие handleEvent
2. Нужно как-то отработать старт сервиса. При старте сервиса мы можем сделать какие-то начальные установки. 
    Сделаем это при помощи посылки в сервис евента startService.

Для реализации вебсервера нам нужно сделать так, чтобы в сервис приходил евент httpEvent::RequestIncoming.
А ответ мы делаем при помощи некоего класса HTTP::Response, которые использует данные из httpEvent::RequestIncoming для формирования ответа.

Итак мы можем полностью инкапсулировать в потроха своего фреймворка работу с сокетами, http протоколом и на выходе оставить прикладному программисту 
максимально упрощенный способ делать http server.

Мы получили сервисную архитектуру. В ней софт разбивается на множество сервисов, которые общаются между собой событиями.

Eсть ли в сервисной архитектуре функция main() ?
Eе там нет, точнее она есть где-то в потрохах фреймворка. 
Что нам нужно, для запуска нашего сервера? Нам нужно загрузить наш сервис в память и дать ему старт. 
На старте он посылает евент сервису HTTP - doListen(sockaddr)
Сам сервис HTTP создает сокет и посылает его в сервис Socket, чтобы тот его мультиплексировал, читал и писал данные.

Как проще всего стартовать наш сервис?
Указать его в конфиге фреймворка.
Делаем поле:
Start=DemoWeb
где DemoWeb имя нашего сервиса, под которым мы его зарегистрировали во фреймворке.


Свойства сервисов

1. Изоляция данных. Сервисы выполняются в виде длл, не имеют между собой никаких общих данных. Влиять на данные друг друга невозможно. 
2. Один поток eventloop. Внутри сервиса не нужно связываться с мутексами и атомиками - это гарантия от ошибок, которые трудно найти. 
    Отсутствие мутексов - это и высокое быстродействие.
    Не нужна высокая квалификация программирования, с программированием может справиться любой инженер, 
    разработавший девайс и решивший написать под него сервис.
3. Сервисы взаимодействуют исключительно при помощи событий. Это простая структура на C++, написанная определенным образом. 
    Чтобы написать новый евент, нужно скопипастить какой-то другой евент и поменять в нем члены класса на свои.

